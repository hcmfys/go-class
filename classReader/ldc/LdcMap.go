package ldc

type  Ldc_Code struct {
	CodeId int
	CodeTxt string
	CodeBytes int
	Desc string
}

func (l * Ldc_Code)  GetIdcMap()  map[int] Ldc_Code {

	ldcMap := make(map[int]Ldc_Code)
	ldcMap[0x00] = Ldc_Code{CodeId: 0x00, CodeTxt: "nop",  CodeBytes: 0, Desc: "无操作"}
	ldcMap[0x01] = Ldc_Code{CodeId: 0x01, CodeTxt: "aconst_null",  CodeBytes: 0, Desc: "将null推送至栈顶"}
	ldcMap[0x02] = Ldc_Code{CodeId: 0x02, CodeTxt: "iconst_m1",  CodeBytes: 0, Desc: "将int型-1推送至栈顶"}
	ldcMap[0x03] = Ldc_Code{CodeId: 0x03, CodeTxt: "iconst_0",  CodeBytes: 0, Desc: "将int型0推送至栈顶"}
	ldcMap[0x04] = Ldc_Code{CodeId: 0x04, CodeTxt: "iconst_1",  CodeBytes: 0, Desc: "将int型1推送至栈顶"}
	ldcMap[0x05] = Ldc_Code{CodeId: 0x05, CodeTxt: "iconst_2",  CodeBytes: 0, Desc: "将int型2推送至栈顶"}
	ldcMap[0x06] = Ldc_Code{CodeId: 0x06, CodeTxt: "iconst_3",  CodeBytes: 0, Desc: "将int型3推送至栈顶"}
	ldcMap[0x07] = Ldc_Code{CodeId: 0x07, CodeTxt: "iconst_4",  CodeBytes: 0, Desc: "将int型4推送至栈顶"}
	ldcMap[0x08] = Ldc_Code{CodeId: 0x08, CodeTxt: "iconst_5",  CodeBytes: 0, Desc: "将int型5推送至栈顶"}
	ldcMap[0x09] = Ldc_Code{CodeId: 0x09, CodeTxt: "lconst_0",  CodeBytes: 0, Desc: "将long型0推送至栈顶"}
	ldcMap[0x0a] = Ldc_Code{CodeId: 0x0a, CodeTxt: "lconst_1",  CodeBytes: 0, Desc: "将long型1推送至栈顶"}
	ldcMap[0x0b] = Ldc_Code{CodeId: 0x0b, CodeTxt: "fconst_0",  CodeBytes: 0, Desc: "将float型0推送至栈顶"}
	ldcMap[0x0c] = Ldc_Code{CodeId: 0x0c, CodeTxt: "fconst_1",  CodeBytes: 0, Desc: "将float型1推送至栈顶"}
	ldcMap[0x0d] = Ldc_Code{CodeId: 0x0d, CodeTxt: "fconst_2",  CodeBytes: 0, Desc: "将float型2推送至栈顶"}
	ldcMap[0x0e] = Ldc_Code{CodeId: 0x0e, CodeTxt: "dconst_0",  CodeBytes: 0, Desc: "将double型0推送至栈顶"}
	ldcMap[0x0f] = Ldc_Code{CodeId: 0x0f, CodeTxt: "dconst_1",  CodeBytes: 0, Desc: "将double型1推送至栈顶"}
	ldcMap[0x10] = Ldc_Code{CodeId: 0x10, CodeTxt: "bipush",  CodeBytes: 0, Desc: "将单字节的常量值(-128~127)推送至栈顶"}
	ldcMap[0x11] = Ldc_Code{CodeId: 0x11, CodeTxt: "sipush",  CodeBytes: 0, Desc: "将一个短整型常量值(-32768~32767)推送至栈顶"}
	ldcMap[0x12] = Ldc_Code{CodeId: 0x12, CodeTxt: "ldc",  CodeBytes: 1, Desc: "将int,"}
	ldcMap[0x13] = Ldc_Code{CodeId: 0x13, CodeTxt: "ldc_w",  CodeBytes: 2, Desc: "将int,"}
	ldcMap[0x14] = Ldc_Code{CodeId: 0x14, CodeTxt: "ldc2_w",  CodeBytes: 2, Desc: "将long或double型常量值从常量池中推送至栈顶（宽索引）"}
	ldcMap[0x15] = Ldc_Code{CodeId: 0x15, CodeTxt: "iload",  CodeBytes: 0, Desc: "将指定的int型本地变量推送至栈顶"}
	ldcMap[0x16] = Ldc_Code{CodeId: 0x16, CodeTxt: "lload",  CodeBytes: 0, Desc: "将指定的long型本地变量推送至栈顶"}
	ldcMap[0x17] = Ldc_Code{CodeId: 0x17, CodeTxt: "fload",  CodeBytes: 0, Desc: "将指定的float型本地变量推送至栈顶"}
	ldcMap[0x18] = Ldc_Code{CodeId: 0x18, CodeTxt: "dload",  CodeBytes: 0, Desc: "将指定的double型本地变量推送至栈顶"}
	ldcMap[0x19] = Ldc_Code{CodeId: 0x19, CodeTxt: "aload",  CodeBytes: 0, Desc: "将指定的引用类型本地变量推送至栈顶"}
	ldcMap[0x1a] = Ldc_Code{CodeId: 0x1a, CodeTxt: "iload_0",  CodeBytes: 0, Desc: "将第一个int型本地变量推送至栈顶"}
	ldcMap[0x1b] = Ldc_Code{CodeId: 0x1b, CodeTxt: "iload_1",  CodeBytes: 0, Desc: "将第二个int型本地变量推送至栈顶"}
	ldcMap[0x1c] = Ldc_Code{CodeId: 0x1c, CodeTxt: "iload_2",  CodeBytes: 0, Desc: "将第三个int型本地变量推送至栈顶"}
	ldcMap[0x1d] = Ldc_Code{CodeId: 0x1d, CodeTxt: "iload_3",  CodeBytes: 0, Desc: "将第四个int型本地变量推送至栈顶"}
	ldcMap[0x1e] = Ldc_Code{CodeId: 0x1e, CodeTxt: "lload_0",  CodeBytes: 0, Desc: "将第一个long型本地变量推送至栈顶"}
	ldcMap[0x1f] = Ldc_Code{CodeId: 0x1f, CodeTxt: "lload_1",  CodeBytes: 0, Desc: "将第二个long型本地变量推送至栈顶"}
	ldcMap[0x20] = Ldc_Code{CodeId: 0x20, CodeTxt: "lload_2",  CodeBytes: 0, Desc: "将第三个long型本地变量推送至栈顶"}
	ldcMap[0x21] = Ldc_Code{CodeId: 0x21, CodeTxt: "lload_3",  CodeBytes: 0, Desc: "将第四个long型本地变量推送至栈顶"}
	ldcMap[0x22] = Ldc_Code{CodeId: 0x22, CodeTxt: "fload_0",  CodeBytes: 0, Desc: "将第一个float型本地变量推送至栈顶"}
	ldcMap[0x23] = Ldc_Code{CodeId: 0x23, CodeTxt: "fload_1",  CodeBytes: 0, Desc: "将第二个float型本地变量推送至栈顶"}
	ldcMap[0x24] = Ldc_Code{CodeId: 0x24, CodeTxt: "fload_2",  CodeBytes: 0, Desc: "将第三个float型本地变量推送至栈顶"}
	ldcMap[0x25] = Ldc_Code{CodeId: 0x25, CodeTxt: "fload_3",  CodeBytes: 0, Desc: "将第四个float型本地变量推送至栈顶"}
	ldcMap[0x26] = Ldc_Code{CodeId: 0x26, CodeTxt: "dload_0",  CodeBytes: 0, Desc: "将第一个double型本地变量推送至栈顶"}
	ldcMap[0x27] = Ldc_Code{CodeId: 0x27, CodeTxt: "dload_1",  CodeBytes: 0, Desc: "将第二个double型本地变量推送至栈顶"}
	ldcMap[0x28] = Ldc_Code{CodeId: 0x28, CodeTxt: "dload_2",  CodeBytes: 0, Desc: "将第三个double型本地变量推送至栈顶"}
	ldcMap[0x29] = Ldc_Code{CodeId: 0x29, CodeTxt: "dload_3",  CodeBytes: 0, Desc: "将第四个double型本地变量推送至栈顶"}
	ldcMap[0x2a] = Ldc_Code{CodeId: 0x2a, CodeTxt: "aload_0",  CodeBytes: 0, Desc: "将第一个引用类型本地变量推送至栈顶"}
	ldcMap[0x2b] = Ldc_Code{CodeId: 0x2b, CodeTxt: "aload_1",  CodeBytes: 0, Desc: "将第二个引用类型本地变量推送至栈顶"}
	ldcMap[0x2c] = Ldc_Code{CodeId: 0x2c, CodeTxt: "aload_2",  CodeBytes: 0, Desc: "将第三个引用类型本地变量推送至栈顶"}
	ldcMap[0x2d] = Ldc_Code{CodeId: 0x2d, CodeTxt: "aload_3",  CodeBytes: 0, Desc: "将第四个引用类型本地变量推送至栈顶"}
	ldcMap[0x2e] = Ldc_Code{CodeId: 0x2e, CodeTxt: "iaload",  CodeBytes: 0, Desc: "将int型数组指定索引的值推送至栈顶"}
	ldcMap[0x2f] = Ldc_Code{CodeId: 0x2f, CodeTxt: "laload",  CodeBytes: 0, Desc: "将long型数组指定索引的值推送至栈顶"}
	ldcMap[0x30] = Ldc_Code{CodeId: 0x30, CodeTxt: "faload",  CodeBytes: 0, Desc: "将float型数组指定索引的值推送至栈顶"}
	ldcMap[0x31] = Ldc_Code{CodeId: 0x31, CodeTxt: "daload",  CodeBytes: 0, Desc: "将double型数组指定索引的值推送至栈顶"}
	ldcMap[0x32] = Ldc_Code{CodeId: 0x32, CodeTxt: "aaload",  CodeBytes: 0, Desc: "将引用型数组指定索引的值推送至栈顶"}
	ldcMap[0x33] = Ldc_Code{CodeId: 0x33, CodeTxt: "baload",  CodeBytes: 0, Desc: "将boolean或byte型数组指定索引的值推送至栈顶"}
	ldcMap[0x34] = Ldc_Code{CodeId: 0x34, CodeTxt: "caload",  CodeBytes: 0, Desc: "将char型数组指定索引的值推送至栈顶"}
	ldcMap[0x35] = Ldc_Code{CodeId: 0x35, CodeTxt: "saload",  CodeBytes: 0, Desc: "将short型数组指定索引的值推送至栈顶"}
	ldcMap[0x36] = Ldc_Code{CodeId: 0x36, CodeTxt: "istore",  CodeBytes: 0, Desc: "将栈顶int型数值存入指定本地变量"}
	ldcMap[0x37] = Ldc_Code{CodeId: 0x37, CodeTxt: "lstore",  CodeBytes: 0, Desc: "将栈顶long型数值存入指定本地变量"}
	ldcMap[0x38] = Ldc_Code{CodeId: 0x38, CodeTxt: "fstore",  CodeBytes: 0, Desc: "将栈顶float型数值存入指定本地变量"}
	ldcMap[0x39] = Ldc_Code{CodeId: 0x39, CodeTxt: "dstore",  CodeBytes: 0, Desc: "将栈顶double型数值存入指定本地变量"}
	ldcMap[0x3a] = Ldc_Code{CodeId: 0x3a, CodeTxt: "astore",  CodeBytes: 0, Desc: "将栈顶引用型数值存入指定本地变量"}
	ldcMap[0x3b] = Ldc_Code{CodeId: 0x3b, CodeTxt: "istore_0",  CodeBytes: 0, Desc: "将栈顶int型数值存入第一个本地变量"}
	ldcMap[0x3c] = Ldc_Code{CodeId: 0x3c, CodeTxt: "istore_1",  CodeBytes: 0, Desc: "将栈顶int型数值存入第二个本地变量"}
	ldcMap[0x3d] = Ldc_Code{CodeId: 0x3d, CodeTxt: "istore_2",  CodeBytes: 0, Desc: "将栈顶int型数值存入第三个本地变量"}
	ldcMap[0x3e] = Ldc_Code{CodeId: 0x3e, CodeTxt: "istore_3",  CodeBytes: 0, Desc: "将栈顶int型数值存入第四个本地变量"}
	ldcMap[0x3f] = Ldc_Code{CodeId: 0x3f, CodeTxt: "lstore_0",  CodeBytes: 0, Desc: "将栈顶long型数值存入第一个本地变量"}
	ldcMap[0x40] = Ldc_Code{CodeId: 0x40, CodeTxt: "lstore_1",  CodeBytes: 0, Desc: "将栈顶long型数值存入第二个本地变量"}
	ldcMap[0x41] = Ldc_Code{CodeId: 0x41, CodeTxt: "lstore_2",  CodeBytes: 0, Desc: "将栈顶long型数值存入第三个本地变量"}
	ldcMap[0x42] = Ldc_Code{CodeId: 0x42, CodeTxt: "lstore_3",  CodeBytes: 0, Desc: "将栈顶long型数值存入第四个本地变量"}
	ldcMap[0x43] = Ldc_Code{CodeId: 0x43, CodeTxt: "fstore_0",  CodeBytes: 0, Desc: "将栈顶float型数值存入第一个本地变量"}
	ldcMap[0x44] = Ldc_Code{CodeId: 0x44, CodeTxt: "fstore_1",  CodeBytes: 0, Desc: "将栈顶float型数值存入第二个本地变量"}
	ldcMap[0x45] = Ldc_Code{CodeId: 0x45, CodeTxt: "fstore_2",  CodeBytes: 0, Desc: "将栈顶float型数值存入第三个本地变量"}
	ldcMap[0x46] = Ldc_Code{CodeId: 0x46, CodeTxt: "fstore_3",  CodeBytes: 0, Desc: "将栈顶float型数值存入第四个本地变量"}
	ldcMap[0x47] = Ldc_Code{CodeId: 0x47, CodeTxt: "dstore_0",  CodeBytes: 0, Desc: "将栈顶double型数值存入第一个本地变量"}
	ldcMap[0x48] = Ldc_Code{CodeId: 0x48, CodeTxt: "dstore_1",  CodeBytes: 0, Desc: "将栈顶double型数值存入第二个本地变量"}
	ldcMap[0x49] = Ldc_Code{CodeId: 0x49, CodeTxt: "dstore_2",  CodeBytes: 0, Desc: "将栈顶double型数值存入第三个本地变量"}
	ldcMap[0x4a] = Ldc_Code{CodeId: 0x4a, CodeTxt: "dstore_3",  CodeBytes: 0, Desc: "将栈顶double型数值存入第四个本地变量"}
	ldcMap[0x4b] = Ldc_Code{CodeId: 0x4b, CodeTxt: "astore_0",  CodeBytes: 0, Desc: "将栈顶引用型数值存入第一个本地变量"}
	ldcMap[0x4c] = Ldc_Code{CodeId: 0x4c, CodeTxt: "astore_1",  CodeBytes: 0, Desc: "将栈顶引用型数值存入第二个本地变量"}
	ldcMap[0x4d] = Ldc_Code{CodeId: 0x4d, CodeTxt: "astore_2",  CodeBytes: 0, Desc: "将栈顶引用型数值存入第三个本地变量"}
	ldcMap[0x4e] = Ldc_Code{CodeId: 0x4e, CodeTxt: "astore_3",  CodeBytes: 0, Desc: "将栈顶引用型数值存入第四个本地变量"}
	ldcMap[0x4f] = Ldc_Code{CodeId: 0x4f, CodeTxt: "iastore",  CodeBytes: 0, Desc: "将栈顶int型数值存入指定数组的指定索引位置"}
	ldcMap[0x50] = Ldc_Code{CodeId: 0x50, CodeTxt: "lastore",  CodeBytes: 0, Desc: "将栈顶long型数值存入指定数组的指定索引位置"}
	ldcMap[0x51] = Ldc_Code{CodeId: 0x51, CodeTxt: "fastore",  CodeBytes: 0, Desc: "将栈顶float型数值存入指定数组的指定索引位置"}
	ldcMap[0x52] = Ldc_Code{CodeId: 0x52, CodeTxt: "dastore",  CodeBytes: 0, Desc: "将栈顶double型数值存入指定数组的指定索引位置"}
	ldcMap[0x53] = Ldc_Code{CodeId: 0x53, CodeTxt: "aastore",  CodeBytes: 0, Desc: "将栈顶引用型数值存入指定数组的指定索引位置"}
	ldcMap[0x54] = Ldc_Code{CodeId: 0x54, CodeTxt: "bastore",  CodeBytes: 0, Desc: "将栈顶boolean或byte型数值存入指定数组的指定索引位置"}
	ldcMap[0x55] = Ldc_Code{CodeId: 0x55, CodeTxt: "castore",  CodeBytes: 0, Desc: "将栈顶char型数值存入指定数组的指定索引位置"}
	ldcMap[0x56] = Ldc_Code{CodeId: 0x56, CodeTxt: "sastore",  CodeBytes: 0, Desc: "将栈顶short型数值存入指定数组的指定索引位置"}
	ldcMap[0x57] = Ldc_Code{CodeId: 0x57, CodeTxt: "pop",  CodeBytes: 0, Desc: ""}
	ldcMap[0x58] = Ldc_Code{CodeId: 0x58, CodeTxt: "pop2",  CodeBytes: 0, Desc: "将栈顶的一个（long或double类型的)或两个数值弹出（其它）"}
	ldcMap[0x59] = Ldc_Code{CodeId: 0x59, CodeTxt: "dup",  CodeBytes: 0, Desc: ""}
	ldcMap[0x5a] = Ldc_Code{CodeId: 0x5a, CodeTxt: "dup_x1",  CodeBytes: 0, Desc: "复制栈顶数值并将两个复制值压入栈顶"}
	ldcMap[0x5b] = Ldc_Code{CodeId: 0x5b, CodeTxt: "dup_x2",  CodeBytes: 0, Desc: "复制栈顶数值并将三个（或两个）复制值压入栈顶"}
	ldcMap[0x5c] = Ldc_Code{CodeId: 0x5c, CodeTxt: "dup2",  CodeBytes: 0, Desc: "复制栈顶一个（long或double类型的)或两个（其它）数值并将复制值压入栈顶"}
	ldcMap[0x5d] = Ldc_Code{CodeId: 0x5d, CodeTxt: "dup2_x1",  CodeBytes: 0, Desc: "复制栈顶的一个或两个值，将其插入栈顶那两个或三个值的下面"}
	ldcMap[0x5e] = Ldc_Code{CodeId: 0x5e, CodeTxt: "dup2_x2",  CodeBytes: 0, Desc: "复制栈顶的一个或两个值，将其插入栈顶那两个、三个或四个值的下面"}
	ldcMap[0x5f] = Ldc_Code{CodeId: 0x5f, CodeTxt: "swap",  CodeBytes: 0, Desc: "将栈最顶端的两个数值互换(数值不能是long或double类型的)"}
	ldcMap[0x60] = Ldc_Code{CodeId: 0x60, CodeTxt: "iadd",  CodeBytes: 0, Desc: "将栈顶两int型数值相加并将结果压入栈顶"}
	ldcMap[0x61] = Ldc_Code{CodeId: 0x61, CodeTxt: "ladd",  CodeBytes: 0, Desc: "将栈顶两long型数值相加并将结果压入栈顶"}
	ldcMap[0x62] = Ldc_Code{CodeId: 0x62, CodeTxt: "fadd",  CodeBytes: 0, Desc: "将栈顶两float型数值相加并将结果压入栈顶"}
	ldcMap[0x63] = Ldc_Code{CodeId: 0x63, CodeTxt: "dadd",  CodeBytes: 0, Desc: "将栈顶两double型数值相加并将结果压入栈顶"}
	ldcMap[0x64] = Ldc_Code{CodeId: 0x64, CodeTxt: "isub",  CodeBytes: 0, Desc: "将栈顶两int型数值相减并将结果压入栈顶"}
	ldcMap[0x65] = Ldc_Code{CodeId: 0x65, CodeTxt: "lsub",  CodeBytes: 0, Desc: "将栈顶两long型数值相减并将结果压入栈顶"}
	ldcMap[0x66] = Ldc_Code{CodeId: 0x66, CodeTxt: "fsub",  CodeBytes: 0, Desc: "将栈顶两float型数值相减并将结果压入栈顶"}
	ldcMap[0x67] = Ldc_Code{CodeId: 0x67, CodeTxt: "dsub",  CodeBytes: 0, Desc: "将栈顶两double型数值相减并将结果压入栈顶"}
	ldcMap[0x68] = Ldc_Code{CodeId: 0x68, CodeTxt: "imul",  CodeBytes: 0, Desc: "将栈顶两int型数值相乘并将结果压入栈顶"}
	ldcMap[0x69] = Ldc_Code{CodeId: 0x69, CodeTxt: "lmul",  CodeBytes: 0, Desc: "将栈顶两long型数值相乘并将结果压入栈顶"}
	ldcMap[0x6a] = Ldc_Code{CodeId: 0x6a, CodeTxt: "fmul",  CodeBytes: 0, Desc: "将栈顶两float型数值相乘并将结果压入栈顶"}
	ldcMap[0x6b] = Ldc_Code{CodeId: 0x6b, CodeTxt: "dmul",  CodeBytes: 0, Desc: "将栈顶两double型数值相乘并将结果压入栈顶"}
	ldcMap[0x6c] = Ldc_Code{CodeId: 0x6c, CodeTxt: "idiv",  CodeBytes: 0, Desc: "将栈顶两int型数值相除并将结果压入栈顶"}
	ldcMap[0x6d] = Ldc_Code{CodeId: 0x6d, CodeTxt: "ldiv",  CodeBytes: 0, Desc: "将栈顶两long型数值相除并将结果压入栈顶"}
	ldcMap[0x6e] = Ldc_Code{CodeId: 0x6e, CodeTxt: "fdiv",  CodeBytes: 0, Desc: "将栈顶两float型数值相除并将结果压入栈顶"}
	ldcMap[0x6f] = Ldc_Code{CodeId: 0x6f, CodeTxt: "ddiv",  CodeBytes: 0, Desc: "将栈顶两double型数值相除并将结果压入栈顶"}
	ldcMap[0x70] = Ldc_Code{CodeId: 0x70, CodeTxt: "irem",  CodeBytes: 0, Desc: "将栈顶两int型数值作取模运算并将结果压入栈顶"}
	ldcMap[0x71] = Ldc_Code{CodeId: 0x71, CodeTxt: "lrem",  CodeBytes: 0, Desc: "将栈顶两long型数值作取模运算并将结果压入栈顶"}
	ldcMap[0x72] = Ldc_Code{CodeId: 0x72, CodeTxt: "frem",  CodeBytes: 0, Desc: "将栈顶两float型数值作取模运算并将结果压入栈顶"}
	ldcMap[0x73] = Ldc_Code{CodeId: 0x73, CodeTxt: "drem",  CodeBytes: 0, Desc: "将栈顶两double型数值作取模运算并将结果压入栈顶"}
	ldcMap[0x74] = Ldc_Code{CodeId: 0x74, CodeTxt: "ineg",  CodeBytes: 0, Desc: "将栈顶int型数值取负并将结果压入栈顶"}
	ldcMap[0x75] = Ldc_Code{CodeId: 0x75, CodeTxt: "lneg",  CodeBytes: 0, Desc: "将栈顶long型数值取负并将结果压入栈顶"}
	ldcMap[0x76] = Ldc_Code{CodeId: 0x76, CodeTxt: "fneg",  CodeBytes: 0, Desc: "将栈顶float型数值取负并将结果压入栈顶"}
	ldcMap[0x77] = Ldc_Code{CodeId: 0x77, CodeTxt: "dneg",  CodeBytes: 0, Desc: "将栈顶double型数值取负并将结果压入栈顶"}
	ldcMap[0x78] = Ldc_Code{CodeId: 0x78, CodeTxt: "ishl",  CodeBytes: 0, Desc: "将int型数值左移位指定位数并将结果压入栈顶"}
	ldcMap[0x79] = Ldc_Code{CodeId: 0x79, CodeTxt: "lshl",  CodeBytes: 0, Desc: "将long型数值左移位指定位数并将结果压入栈顶"}
	ldcMap[0x7a] = Ldc_Code{CodeId: 0x7a, CodeTxt: "ishr",  CodeBytes: 0, Desc: "将int型数值右（符号）移位指定位数并将结果压入栈顶"}
	ldcMap[0x7b] = Ldc_Code{CodeId: 0x7b, CodeTxt: "lshr",  CodeBytes: 0, Desc: "将long型数值右（符号）移位指定位数并将结果压入栈顶"}
	ldcMap[0x7c] = Ldc_Code{CodeId: 0x7c, CodeTxt: "iushr",  CodeBytes: 0, Desc: "将int型数值右（无符号）移位指定位数并将结果压入栈顶"}
	ldcMap[0x7d] = Ldc_Code{CodeId: 0x7d, CodeTxt: "lushr",  CodeBytes: 0, Desc: "将long型数值右（无符号）移位指定位数并将结果压入栈顶"}
	ldcMap[0x7e] = Ldc_Code{CodeId: 0x7e, CodeTxt: "iand",  CodeBytes: 0, Desc: "将栈顶两int型数值作“按位与”并将结果压入栈顶"}
	ldcMap[0x7f] = Ldc_Code{CodeId: 0x7f, CodeTxt: "land",  CodeBytes: 0, Desc: "将栈顶两long型数值作“按位与”并将结果压入栈顶"}
	ldcMap[0x80] = Ldc_Code{CodeId: 0x80, CodeTxt: "ior",  CodeBytes: 0, Desc: ""}
	ldcMap[0x81] = Ldc_Code{CodeId: 0x81, CodeTxt: "lor",  CodeBytes: 0, Desc: ""}
	ldcMap[0x82] = Ldc_Code{CodeId: 0x82, CodeTxt: "ixor",  CodeBytes: 0, Desc: "将栈顶两int型数值作“按位异或”并将结果压入栈顶"}
	ldcMap[0x83] = Ldc_Code{CodeId: 0x83, CodeTxt: "lxor",  CodeBytes: 0, Desc: "将栈顶两long型数值作“按位异或”并将结果压入栈顶"}
	ldcMap[0x84] = Ldc_Code{CodeId: 0x84, CodeTxt: "iinc",  CodeBytes: 0, Desc: "将指定int型变量增加指定值（i++,"}
	ldcMap[0x85] = Ldc_Code{CodeId: 0x85, CodeTxt: "i2l",  CodeBytes: 0, Desc: ""}
	ldcMap[0x86] = Ldc_Code{CodeId: 0x86, CodeTxt: "i2f",  CodeBytes: 0, Desc: ""}
	ldcMap[0x87] = Ldc_Code{CodeId: 0x87, CodeTxt: "i2d",  CodeBytes: 0, Desc: ""}
	ldcMap[0x88] = Ldc_Code{CodeId: 0x88, CodeTxt: "l2i",  CodeBytes: 0, Desc: ""}
	ldcMap[0x89] = Ldc_Code{CodeId: 0x89, CodeTxt: "l2f",  CodeBytes: 0, Desc: ""}
	ldcMap[0x8a] = Ldc_Code{CodeId: 0x8a, CodeTxt: "l2d",  CodeBytes: 0, Desc: ""}
	ldcMap[0x8b] = Ldc_Code{CodeId: 0x8b, CodeTxt: "f2i",  CodeBytes: 0, Desc: ""}
	ldcMap[0x8c] = Ldc_Code{CodeId: 0x8c, CodeTxt: "f2l",  CodeBytes: 0, Desc: ""}
	ldcMap[0x8d] = Ldc_Code{CodeId: 0x8d, CodeTxt: "f2d",  CodeBytes: 0, Desc: ""}
	ldcMap[0x8e] = Ldc_Code{CodeId: 0x8e, CodeTxt: "d2i",  CodeBytes: 0, Desc: ""}
	ldcMap[0x8f] = Ldc_Code{CodeId: 0x8f, CodeTxt: "d2l",  CodeBytes: 0, Desc: ""}
	ldcMap[0x90] = Ldc_Code{CodeId: 0x90, CodeTxt: "d2f",  CodeBytes: 0, Desc: ""}
	ldcMap[0x91] = Ldc_Code{CodeId: 0x91, CodeTxt: "i2b",  CodeBytes: 0, Desc: ""}
	ldcMap[0x92] = Ldc_Code{CodeId: 0x92, CodeTxt: "i2c",  CodeBytes: 0, Desc: ""}
	ldcMap[0x93] = Ldc_Code{CodeId: 0x93, CodeTxt: "i2s",  CodeBytes: 0, Desc: ""}
	ldcMap[0x94] = Ldc_Code{CodeId: 0x94, CodeTxt: "lcmp",  CodeBytes: 0, Desc: "比较栈顶两long型数值大小，并将结果（1，0，-1）压入栈顶"}
	ldcMap[0x95] = Ldc_Code{CodeId: 0x95, CodeTxt: "fcmpl",  CodeBytes: 0, Desc: "比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶"}
	ldcMap[0x96] = Ldc_Code{CodeId: 0x96, CodeTxt: "fcmpg",  CodeBytes: 0, Desc: "比较栈顶两float型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶"}
	ldcMap[0x97] = Ldc_Code{CodeId: 0x97, CodeTxt: "dcmpl",  CodeBytes: 0, Desc: "比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将-1压入栈顶"}
	ldcMap[0x98] = Ldc_Code{CodeId: 0x98, CodeTxt: "dcmpg",  CodeBytes: 0, Desc: "比较栈顶两double型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为NaN时，将1压入栈顶"}
	ldcMap[0x99] = Ldc_Code{CodeId: 0x99, CodeTxt: "ifeq",  CodeBytes: 0, Desc: "当栈顶int型数值等于0时跳转"}
	ldcMap[0x9a] = Ldc_Code{CodeId: 0x9a, CodeTxt: "ifne",  CodeBytes: 0, Desc: "当栈顶int型数值不等于0时跳转"}
	ldcMap[0x9b] = Ldc_Code{CodeId: 0x9b, CodeTxt: "iflt",  CodeBytes: 0, Desc: "当栈顶int型数值小于0时跳转"}
	ldcMap[0x9c] = Ldc_Code{CodeId: 0x9c, CodeTxt: "ifge",  CodeBytes: 0, Desc: "当栈顶int型数值大于等于0时跳转"}
	ldcMap[0x9d] = Ldc_Code{CodeId: 0x9d, CodeTxt: "ifgt",  CodeBytes: 0, Desc: "当栈顶int型数值大于0时跳转"}
	ldcMap[0x9e] = Ldc_Code{CodeId: 0x9e, CodeTxt: "ifle",  CodeBytes: 0, Desc: "当栈顶int型数值小于等于0时跳转"}
	ldcMap[0x9f] = Ldc_Code{CodeId: 0x9f, CodeTxt: "if_icmpeq",  CodeBytes: 0, Desc: "比较栈顶两int型数值大小，当结果等于0时跳转"}
	ldcMap[0xa0] = Ldc_Code{CodeId: 0xa0, CodeTxt: "if_icmpne",  CodeBytes: 0, Desc: "比较栈顶两int型数值大小，当结果不等于0时跳转"}
	ldcMap[0xa1] = Ldc_Code{CodeId: 0xa1, CodeTxt: "if_icmplt",  CodeBytes: 0, Desc: "比较栈顶两int型数值大小，当结果小于0时跳转"}
	ldcMap[0xa2] = Ldc_Code{CodeId: 0xa2, CodeTxt: "if_icmpge",  CodeBytes: 0, Desc: "比较栈顶两int型数值大小，当结果大于等于0时跳转"}
	ldcMap[0xa3] = Ldc_Code{CodeId: 0xa3, CodeTxt: "if_icmpgt",  CodeBytes: 0, Desc: "比较栈顶两int型数值大小，当结果大于0时跳转"}
	ldcMap[0xa4] = Ldc_Code{CodeId: 0xa4, CodeTxt: "if_icmple",  CodeBytes: 0, Desc: "比较栈顶两int型数值大小，当结果小于等于0时跳转"}
	ldcMap[0xa5] = Ldc_Code{CodeId: 0xa5, CodeTxt: "if_acmpeq",  CodeBytes: 0, Desc: "比较栈顶两引用型数值，当结果相等时跳转"}
	ldcMap[0xa6] = Ldc_Code{CodeId: 0xa6, CodeTxt: "if_acmpne",  CodeBytes: 0, Desc: "比较栈顶两引用型数值，当结果不相等时跳转"}
	ldcMap[0xa7] = Ldc_Code{CodeId: 0xa7, CodeTxt: "goto",  CodeBytes: 2, Desc: "无条件跳转"}
	ldcMap[0xa8] = Ldc_Code{CodeId: 0xa8, CodeTxt: "jsr",  CodeBytes: 2, Desc: ""}
	ldcMap[0xa9] = Ldc_Code{CodeId: 0xa9, CodeTxt: "ret",  CodeBytes: 0, Desc: ""}
	ldcMap[0xaa] = Ldc_Code{CodeId: 0xaa, CodeTxt: "tableswitch",  CodeBytes: 0, Desc: "用于switch条件跳转，case值连续（可变长度指令）"}
	ldcMap[0xab] = Ldc_Code{CodeId: 0xab, CodeTxt: "lookupswitch",  CodeBytes: 0, Desc: "用于switch条件跳转，case值不连续（可变长度指令）"}
	ldcMap[0xac] = Ldc_Code{CodeId: 0xac, CodeTxt: "ireturn",  CodeBytes: 0, Desc: "从当前方法返回int"}
	ldcMap[0xad] = Ldc_Code{CodeId: 0xad, CodeTxt: "lreturn",  CodeBytes: 0, Desc: "从当前方法返回long"}
	ldcMap[0xae] = Ldc_Code{CodeId: 0xae, CodeTxt: "freturn",  CodeBytes: 0, Desc: "从当前方法返回float"}
	ldcMap[0xaf] = Ldc_Code{CodeId: 0xaf, CodeTxt: "dreturn",  CodeBytes: 0, Desc: "从当前方法返回double"}
	ldcMap[0xb0] = Ldc_Code{CodeId: 0xb0, CodeTxt: "areturn",  CodeBytes: 0, Desc: "从当前方法返回对象引用"}
	ldcMap[0xb1] = Ldc_Code{CodeId: 0xb1, CodeTxt: "return",  CodeBytes: 0, Desc: "从当前方法返回void"}
	ldcMap[0xb2] = Ldc_Code{CodeId: 0xb2, CodeTxt: "getstatic",  CodeBytes: 0, Desc: "获取指定类的静态域，并将其值压入栈顶"}
	ldcMap[0xb3] = Ldc_Code{CodeId: 0xb3, CodeTxt: "putstatic",  CodeBytes: 0, Desc: "为指定的类的静态域赋值"}
	ldcMap[0xb4] = Ldc_Code{CodeId: 0xb4, CodeTxt: "getfield",  CodeBytes: 2, Desc: "获取指定类的实例域，并将其值压入栈顶"}
	ldcMap[0xb5] = Ldc_Code{CodeId: 0xb5, CodeTxt: "putfield",  CodeBytes: 2, Desc: "为指定的类的实例域赋值"}
	ldcMap[0xb6] = Ldc_Code{CodeId: 0xb6, CodeTxt: "invokevirtual",  CodeBytes: 2, Desc: "调用实例方法"}
	ldcMap[0xb7] = Ldc_Code{CodeId: 0xb7, CodeTxt: "invokespecial",  CodeBytes: 2, Desc: "调用超类构造方法，实例初始化方法，私有方法"}
	ldcMap[0xb8] = Ldc_Code{CodeId: 0xb8, CodeTxt: "invokestatic",  CodeBytes: 2, Desc: "调用静态方法"}
	ldcMap[0xb9] = Ldc_Code{CodeId: 0xb9, CodeTxt: "invokeinterface",  CodeBytes: 2, Desc: "调用接口方法"}
	ldcMap[0xba] = Ldc_Code{CodeId: 0xba, CodeTxt: "invokedynamic",  CodeBytes: 2, Desc: ""}
	ldcMap[0xbb] = Ldc_Code{CodeId: 0xbb, CodeTxt: "new",  CodeBytes: 2, Desc: ""}
	ldcMap[0xbc] = Ldc_Code{CodeId: 0xbc, CodeTxt: "newarray",  CodeBytes: 1, Desc: "创建一个指定原始类型（如int,"}
	ldcMap[0xbd] = Ldc_Code{CodeId: 0xbd, CodeTxt: "anewarray",  CodeBytes: 2, Desc: "创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶"}
	ldcMap[0xbe] = Ldc_Code{CodeId: 0xbe, CodeTxt: "arraylength",  CodeBytes: 0, Desc: "获得数组的长度值并压入栈顶"}
	ldcMap[0xbf] = Ldc_Code{CodeId: 0xbf, CodeTxt: "athrow",  CodeBytes: 0, Desc: "将栈顶的异常抛出"}
	ldcMap[0xc0] = Ldc_Code{CodeId: 0xc0, CodeTxt: "checkcast",  CodeBytes: 0, Desc: "检验类型转换，检验未通过将抛出ClassCastException"}
	ldcMap[0xc1] = Ldc_Code{CodeId: 0xc1, CodeTxt: "instanceof",  CodeBytes: 0, Desc: "检验对象是否是指定的类的实例，如果是将1压入栈顶，否则将0压入栈顶"}
	ldcMap[0xc2] = Ldc_Code{CodeId: 0xc2, CodeTxt: "monitorenter",  CodeBytes: 0, Desc: "获得对象的锁，用于同步方法或同步块"}
	ldcMap[0xc3] = Ldc_Code{CodeId: 0xc3, CodeTxt: "monitorexit",  CodeBytes: 0, Desc: "释放对象的锁，用于同步方法或同步块"}
	ldcMap[0xc4] = Ldc_Code{CodeId: 0xc4, CodeTxt: "wide",  CodeBytes: 4, Desc: "扩大本地变量索引的宽度"}
	ldcMap[0xc5] = Ldc_Code{CodeId: 0xc5, CodeTxt: "multianewarray",  CodeBytes: 0, Desc: "创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶"}
	ldcMap[0xc6] = Ldc_Code{CodeId: 0xc6, CodeTxt: "ifnull",  CodeBytes: 0, Desc: "为null时跳转"}
	ldcMap[0xc7] = Ldc_Code{CodeId: 0xc7, CodeTxt: "ifnonnull",  CodeBytes: 0, Desc: "不为null时跳转"}
	ldcMap[0xc8] = Ldc_Code{CodeId: 0xc8, CodeTxt: "goto_w",  CodeBytes: 2, Desc: "无条件跳转"}
	ldcMap[0xc9] = Ldc_Code{CodeId: 0xc9, CodeTxt: "jsr_w",  CodeBytes: 4, Desc: "跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶"}
	ldcMap[0xca] = Ldc_Code{CodeId: 0xca, CodeTxt: "breakpoint",  CodeBytes: 0, Desc: ""}
	ldcMap[0xfe] = Ldc_Code{CodeId: 0xfe, CodeTxt: "impdep1",  CodeBytes: 0, Desc: "为特定软件而预留的语言后门"}

	return ldcMap

}

